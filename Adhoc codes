F.when(
    (F.col("PassFailFlag") == "Fail") &
    (F.col(comm_col).isNotNull()) &
    (~isnan(F.col(comm_col))) &
    (F.trim(F.col(comm_col)).isin("", "0", "0.0") == False),
    "Pass"
).otherwise("Fail").alias("Existence_Status")
)




�� ADDH Intercompany dividend payable

joined_df = joined_df.withColumn(
    "fsli",
    F.regexp_replace(F.regexp_replace(F.regexp_replace("fsli", r"[^\x00-\x7F]", ""), r"\\s+", " "), r"^\\s+|\\s+$", "")
)


from openpyxl import load_workbook
from openpyxl.workbook.calc_props import CalcProperties

def enable_auto_calc(file_in, file_out):
    wb = load_workbook(file_in)

    # Check if _calcPr exists, if not, create one
    if not hasattr(wb, '_calcPr') or wb._calcPr is None:
        wb._calcPr = CalcProperties(calcMode='auto', fullCalcOnLoad=True)
    else:
        wb._calcPr.calcMode = 'auto'
        wb._calcPr.fullCalcOnLoad = True

    wb.save(file_out)
    print(f"Saved workbook with automatic calculation: {file_out}")

# Example usage
enable_auto_calc('input.xlsx', 'output_auto_calc.xlsx')




import zipfile
import shutil
import os
from lxml import etree

def set_calc_mode_auto(xlsx_path, output_path):
    temp_dir = 'temp_xlsx'
    
    # 1. Extract the XLSX contents to a temp directory
    with zipfile.ZipFile(xlsx_path, 'r') as zip_ref:
        zip_ref.extractall(temp_dir)
    
    # 2. Path to the workbook.xml inside extracted folder
    workbook_xml_path = os.path.join(temp_dir, 'xl', 'workbook.xml')
    
    # 3. Parse workbook.xml with lxml
    parser = etree.XMLParser(remove_blank_text=True)
    tree = etree.parse(workbook_xml_path, parser)
    root = tree.getroot()
    
    # 4. Find workbookPr element and update calcMode attribute
    # Excel namespace
    ns = {'ns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'}
    workbookPr = root.find('ns:workbookPr', ns)
    
    if workbookPr is None:
        # If not found, create it
        workbookPr = etree.Element('{http://schemas.openxmlformats.org/spreadsheetml/2006/main}workbookPr')
        root.insert(0, workbookPr)
    
    # Set calcMode attribute to auto
    workbookPr.set('calcMode', 'auto')
    
    # 5. Write back the modified XML
    tree.write(workbook_xml_path, pretty_print=True, xml_declaration=True, encoding='UTF-8')
    
    # 6. Re-zip the folder contents into a new XLSX file
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zip_out:
        for foldername, subfolders, filenames in os.walk(temp_dir):
            for filename in filenames:
                file_path = os.path.join(foldername, filename)
                # archive name should be relative to temp_dir
                archive_name = os.path.relpath(file_path, temp_dir)
                zip_out.write(file_path, archive_name)
    
    # 7. Cleanup temp directory
    shutil.rmtree(temp_dir)

# Usage example
set_calc_mode_auto('input_workbook.xlsx', 'output_workbook_auto_calc.xlsx')






import zipfile
import shutil
import os
from lxml import etree

def set_calc_mode_auto(xlsx_path, output_path):
    temp_dir = 'temp_xlsx'
    
    # 1. Extract the XLSX contents to a temp directory
    with zipfile.ZipFile(xlsx_path, 'r') as zip_ref:
        zip_ref.extractall(temp_dir)
    
    # 2. Path to the workbook.xml inside extracted folder
    workbook_xml_path = os.path.join(temp_dir, 'xl', 'workbook.xml')
    
    # 3. Parse workbook.xml with lxml
    parser = etree.XMLParser(remove_blank_text=True)
    tree = etree.parse(workbook_xml_path, parser)
    root = tree.getroot()
    
    # 4. Extract the namespace from root tag, e.g. '{namespace}workbook'
    ns_uri = root.tag[root.tag.find("{")+1 : root.tag.find("}")]
    ns = {'ns': ns_uri}
    
    # 5. Find workbookPr element with the correct namespace
    workbookPr = root.find('ns:workbookPr', namespaces=ns)
    
    if workbookPr is None:
        # Create workbookPr if it doesn't exist
        workbookPr = etree.Element(f'{{{ns_uri}}}workbookPr')
        root.insert(0, workbookPr)
    
    # 6. Set calcMode attribute to auto
    workbookPr.set('calcMode', 'auto')
    
    # 7. Write back the modified XML
    tree.write(workbook_xml_path, pretty_print=True, xml_declaration=True, encoding='UTF-8')
    
    # 8. Re-zip the folder contents into a new XLSX file
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zip_out:
        for foldername, subfolders, filenames in os.walk(temp_dir):
            for filename in filenames:
                file_path = os.path.join(foldername, filename)
                archive_name = os.path.relpath(file_path, temp_dir)
                zip_out.write(file_path, archive_name)
    
    # 9. Cleanup temp directory
    shutil.rmtree(temp_dir)

# Usage
set_calc_mode_auto('input_workbook.xlsx', 'output_workbook_auto_calc.xlsx')





import zipfile
import shutil
import os
from lxml import etree

def set_calc_mode_auto(xlsx_path, output_path):
    temp_dir = 'temp_xlsx'
    
    # Clean temp dir if it exists
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)

    # Step 1: Extract the .xlsx contents
    with zipfile.ZipFile(xlsx_path, 'r') as zip_ref:
        zip_ref.extractall(temp_dir)

    # Step 2: Path to workbook.xml
    workbook_xml_path = os.path.join(temp_dir, 'xl', 'workbook.xml')

    # Step 3: Parse workbook.xml
    parser = etree.XMLParser(remove_blank_text=True)
    tree = etree.parse(workbook_xml_path, parser)
    root = tree.getroot()

    # Step 4: Extract the namespace dynamically
    ns_uri = root.tag[root.tag.find("{")+1 : root.tag.find("}")]
    nsmap = {'ns': ns_uri}

    # Step 5: Find or create <workbookPr>
    workbookPr = root.find('ns:workbookPr', namespaces=nsmap)
    if workbookPr is None:
        workbookPr = etree.Element(f'{{{ns_uri}}}workbookPr')
        root.insert(0, workbookPr)

    # Step 6: Set or update calcMode to "auto"
    workbookPr.set('calcMode', 'auto')

    # Optional: Remove manual-related flags that force manual behavior
    for attr in ['fullCalcOnLoad', 'forceFullCalc']:
        if attr in workbookPr.attrib:
            del workbookPr.attrib[attr]

    # Step 7: Save the modified workbook.xml
    tree.write(workbook_xml_path, pretty_print=True, xml_declaration=True, encoding='UTF-8')

    # Step 8: Repackage everything into a new .xlsx file
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zip_out:
        for foldername, subfolders, filenames in os.walk(temp_dir):
            for filename in filenames:
                file_path = os.path.join(foldername, filename)
                archive_name = os.path.relpath(file_path, temp_dir)
                zip_out.write(file_path, archive_name)

    # Step 9: Cleanup
    shutil.rmtree(temp_dir)

# ✅ Usage
set_calc_mode_auto('input_workbook.xlsx', 'output_workbook_auto_calc.xlsx')






import zipfile
import shutil
import os
from lxml import etree

def set_calc_mode_auto(xlsx_path, output_path):
    temp_dir = 'temp_xlsx'

    # Clean up and create temp dir
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)

    # Step 1: Extract
    with zipfile.ZipFile(xlsx_path, 'r') as zip_ref:
        zip_ref.extractall(temp_dir)

    # Step 2: Modify workbook.xml
    workbook_xml = os.path.join(temp_dir, 'xl', 'workbook.xml')
    parser = etree.XMLParser(remove_blank_text=True)
    tree = etree.parse(workbook_xml, parser)
    root = tree.getroot()

    ns_uri = root.tag[root.tag.find("{")+1 : root.tag.find("}")]
    nsmap = {'ns': ns_uri}

    # Step 3: Find/create workbookPr
    workbookPr = root.find('ns:workbookPr', namespaces=nsmap)
    if workbookPr is None:
        workbookPr = etree.Element(f'{{{ns_uri}}}workbookPr')
        root.insert(0, workbookPr)

    # Step 4: Set calcMode and cleanup other attributes
    workbookPr.attrib.clear()  # clear all attributes
    workbookPr.set('calcMode', 'auto')

    # Optional: Add Excel default calcId (can help with Excel Online)
    workbookPr.set('calcId', '122211')  # example value from new Excel files

    # Step 5: Write back
    tree.write(workbook_xml, pretty_print=True, xml_declaration=True, encoding='UTF-8')

    # Step 6: Re-zip to output_path
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zip_out:
        for root_dir, dirs, files in os.walk(temp_dir):
            for file in files:
                abs_path = os.path.join(root_dir, file)
                rel_path = os.path.relpath(abs_path, temp_dir)
                zip_out.write(abs_path, rel_path)

    # Step 7: Cleanup
    shutil.rmtree(temp_dir)

# Example usage (paths must point to accessible Lakehouse or OneLake locations)
set_calc_mode_auto('input_workbook.xlsx', 'output_workbook_auto_calc.xlsx')
